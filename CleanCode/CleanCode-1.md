代码整洁之道-上
-------------
### 写在前面

代码整洁之道原名Clean Code，作者是Robert C. Martin。本书提出的观点是：代码的质量与其整洁度成正比。干净的代码，质量上更为可靠，同时后期也更容易维护。

本书中作者根据其多年实践经验，为代码的整洁优化提出了一条条经验。

### 第一章 整洁代码

在本章中，作者对提出了整洁代码的概念，并辅以例子说明整洁代码的重要性。

![生产力随时间而变化]()

作者认为“烂代码”（尤其是那些难以维护的代码）严重影响了生产力，甚至会拖垮整个公司。同时，作者援引了多位计算机界大牛对于整洁代码的观点，概括出整洁代码应该具备的一些特点：优雅、高效、直截了当以及鲁棒、精干和全面。

另外，作者提出忠告：保持代码整洁应该在编程的每时每刻都进行，而不是在写好之后，以免陷入LeBlanc法则“稍后等于永不”。

### 第二章 有意义的命名

给变量命名并不是件容易的事情。变量、函数或类名应该答复了所有的问题：它为什么会存在、它要做什么事、应该怎么用等等。体现出命名的本意有利于阅读和理解代码。应该避免采用专有名词等容易误导的命名。选用了好名称之后，对它稍加改动也能区分出它含义的变化。

要做有意义的区分，而不应只是为了满足编译器编译通过。废话通常是冗余。作者不建议将数据类型写到变量名中。

要使用读得出来的名称，而不是自造词。

要使用可搜索的名称，一个经验是名称长短应与它的作用域大小相对应。单字母名称最好只用于短方法中的本地变量。

要避免使用编码，匈牙利语标记法要求首字母体现出类型。不要在变量名前面添加无意义的前缀，因为代码看得越多，人们越容易忽略这些前缀。

要避免思维映射，主要是选择问题领域术语还是解决方案领域术语。专业程序员会写其他人能理解的代码。还是采用解决方案领域术语更佳。当然如果不能使用程序员所熟悉的术语来命名，那就从问题所涉及的领域来命名。优秀的程序员和设计师，其工作之一就是分离解决方案领域和问题领域的概念。

要注意类名不应当是动词，方法名则应当是动词或动词短语。

要避免使用俗语“卖萌”、避免使用双关语。

可以把每个概念对应一个词，并且一以贯之。

添加有意义的语境，来辅助命名自我说明。例如addrFirstName、addrLastName等，而如果写成了GSDaddr、GSDstation等这不是好选择。只要短名称足够清楚，就要比长名称好。

当然，取名字最难的地方在于需要良好的描述技巧和共有文化背景。

### 第三章 函数

难以阅读的函数往往有太多事发生、太多抽象、奇怪的字符串或函数调用、以及多重嵌套等等。

函数应该是短小的，并且只做一件事。判断函数是否不止做了一件事，另一个方法是看是否能拆分出一个新函数。

每个函数一个抽象层级，不要混杂。

向下规则：自顶向下读代码。希望每个函数后面跟着的是它下一个层级的函数。

有这样一些原则：单一权责原则、开放闭合原则。

使用描述性名称，函数越短小，功能越集中，越便于取个好名字。

作者建议函数的参数数量最理想是零，其次是一，再次是二，最好不要是三及以上。从测试的角度看，参数太多让人为难，想要覆盖所有的可能值组合令人生畏。

一元函数有两种场景：转换和事件。

二元函数有时候两个参数会是单个值得有序组成部分，例如复数的实部和虚部。尽量把它们合并吧。

如果是三个或三个以上的参数，就可以合并为类了。

给函数取个好名字，能较好地解释函数的意图。

要小心函数的副作用。可能代码中会有一些隐藏的变化，例如创造了时序上的耦合，这时要在命名中体现时序，例如添加initialize等。

作者认为要分隔指令和询问：函数要么做什么事，要么回答什么事，两者不能得兼。例如要么修改某对象的状态，要么返回该对象的一些信息。

使用异常替代返回错误码: 返回错误码往往要求立即处理错误，而使用异常进行替代，错误处理代码就能从主路径代码中分离出来了。

Try-Catch代码块会搞乱代码结构，最好把它们分离出来，作为函数。而错误处理函数就做一件事。

另外，使用错误码意味着有处地方是枚举了错误码，这样一旦错误码进行了改动，所有对它的引用可能都需要重新编译和部署。使用异常代码错误码，新异常可以从中派生出来。

别重复自己，有许多规则和时间都是为了控制与消除重复而创建。面向方面编程和面向组件编程都是消除重复的一种策略。

Edsger Dijkstra提出了结构化编程规则。他认为每个函数、每个函数中的代码块都应该只有一个入口和一个出口。当然小函数中这并不是大问题。

写函数的过程就像写文章，刚开始也是复杂和冗余，经过了漫长的打磨和改造，才成为了崭新的优雅代码。

### 第四章 注释

好的注释使人们一目了然，坏的注释让人们感觉不知所云。

注释使为了弥补我们在用代码表达意图时遭遇的失败。

注释往往会随着时间而与代码改动步调不一，最后变成了“谎话”。

注释不能美化糟糕的代码：还是应该使得代码更整洁和清晰，而避免将希望全部寄托在注释上。

好的注释可能有：法律信息（版权著作声明等）、提供基本信息（某个抽象方法的返回值等）、对意图的解释（为什么这么做等）、阐释（说明晦涩难懂的参数、返回值等）、警示（警告程序员某种可能的后果等）、TODO注释（工作列表等）、放大（放大某个问题等）。

坏注释：喃喃自语、多余的注释（不能提供比代码更多的信息）、误导性注释、循规式注释（不是每个函数都需要有注释）、日志式注释（冗长的记录会让模块变得混乱不堪）、废话式注释（喋喋不休、毫无新意）。

能用函数或变量时就别用注释。

无用的位置标记。

括号后面的注释，例如{}/while等等，这个时候应该做的是缩短控制。

利用代码版本控制系统比添加归属和署名更有效。

注释掉的代码，为什么要注释掉？为什么不删除了呢？

没有必要的非本地信息就省略去吧。

注释应该和代码紧密相连，而起个好的函数名往往胜过好几行注释。

### 第五章 格式

代码的格式很重要，应该选用一套管理代码格式的简单规则，并进行贯彻。而同一团队也应该采用一套简单的格式规则。

垂直格式：向报纸学习，应该从上到下阅读，并且名称简单一目了然。源文件顶部应给出最高层次概念和算法，细节应该往下渐次展开，直到找到源文件中最底层的函数和细节。

添加适当的空白行。空白行显示了思路，靠近的代码则体现了亲近：关系密切的概念应互相靠近。

变量声明赢尽可能靠近其使用位置，实体变量应该在类的顶部声明，相关函数：若某个函数调用了另外一个，就应该把它们放在一起。概念相关的代码应该放到一起。

水平格式：使用空格将彼此紧密相关的事物连接到一起，也用空格字符将相关性较弱的事物分隔开。

源文件是一种继承结构，而不是大纲结构。另外在代码中尽量不要违反缩进规则。

一组开发者应该用同一种格式风格。 

### 第六章 对象和数据结构

隐藏实现并非只是在变量之间放上一个函数层那么简单，隐藏实现关乎抽象，暴露抽象接口，以便用户无需了解数据的实现就能操作数据本体。

对象把数据隐藏于抽象之后，暴露操作数据的函数。数据结构暴露其数据，没有提供有意义的函数。

过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数，而面向对象代码便于在不改动既有函数的前提下添加新类。反之：过程式代码难以添加新数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类。

德墨忒定律，the Law of Demeter认为：模块不应了解它所操作对象的内部情形。类C的方法f只应该调用一下对象的方法：

* C
* 由f创建的对象
* 作为参数传递给f的对象
* 由C的实体变量持有的对象

连串的调用通常被看作是“火车失事”。

混杂了数据结构和对象增加了添加新函数的难度，也增加了添加新数据结构的难度。

数据传送对象: DTO: Data Transfer Objects，在于数据库等通信、或者解析套接字传递等场景中非常有用。更常见的是豆结构bean，它拥有由赋值器和取值器操作的私有变量。

Active Record是一种特殊的DTO形式，它们拥有公共变量的数据结构，往往也会拥有类似save或find这样的可浏览方法。

### 第七章 错误处理
前面已经提到了使用异常而非错误码。异常的妙处之一是：它们在程序中定义了一个范围，执行try-catch-finally语句中的try部分的代码时，你是在表明可随时取消执行，并在catch语句中继续。try代码块就像是事务，catch代码块将程序维持在一种持续状态。在编写可能抛出异常的代码时，最好先写出try-catch-finally语句。甚至可以在此基础上开展TDD。

可控异常(checked exception)与不可控异常。可控异常的代价是破坏了开放闭合原则。如果catch语句在三个层级之上，你就得在catch语句和抛出异常处之间的每个方法签名中声明该异常。这样会破坏封装。

抛出的每个异常，都应该提供足够的环境说明，以便判断错误的来源和处所。

依调用者定义异常类。

定义常规流程，特例模式（Special Case Pattern）。创建一个类或配置一个对象，用来处理特例。

别返回null值和别传递null值。要注意对null值得检查，或者传递特殊对象。

### 第八章 边界
使用第三方代码，要注意边界。

学习第三方代码很难，整合第三方代码也很难。如果我们不在生产代码中试验新东西，而是编写测试来遍览和理解第三方代码，Jim Newkirk把这叫做学习性测试。

使用尚不存在的代码：即将已知和未知分隔开的边界。Adaptor模式。

我们可以封装那些第三方包，也可以使用Adaptor模式将我们的接口转换为第三方提供的接口。在边界两边推动内部一致的用法，当第三方代码有改动时修改点也会更少。

### 第九章 单元测试
敏捷和TDD鼓舞了许多程序员编写自动化单元测试。

TDD三定律：

* 在编写不能通过的单元测试前，不可编写生产代码
* 只可编写刚好无法通过的单元测试，不能编译也算不通过
* 只可编写刚好足以通过当前失败测试的生产代码

测试代码同样需要做良好设计和仔细划分，测试函数也应该短小和具有描述性。“脏”测试等同于没测试。测试代码和生产代码一样重要。

整洁的测试要素是：可读性。

构造-操作-检验(Build - Operate - Check)模式。第一个环节构造测试数据，第二个环节操作测试数据，第三个环节检验操作是否得到期望的效果。

面向特定领域的测试语言，编写的测试API。

测试代码应该简单、精悍、足具表达力。

每个测试一个断言。每个测试都应该归结为一个可快速方便地理解的结论。

given-when-then约定。利用模板方法(Template Method)模式，将given/when部分放到基类里，将then类放到派生类里，消除代码重复问题。

每个测试一个概念。

F.I.R.S.T:

- Fast，快速
- Independent, 独立
- Repeatable, 可重复
- Self-Validating, 自足验证
- Timely, 及时

